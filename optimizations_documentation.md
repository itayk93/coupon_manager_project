# תיעוד אופטימיזציות בקובץ `profile_routes.py`

מסמך זה מתאר את האופטימיזציות המרכזיות שבוצעו בפונקציה `index` בקובץ `app/routes/profile_routes.py` לשיפור ביצועים.

---

## 1. איחוד שאילתות וטעינה מדורגת (Lazy Loading)

**הבעיה:** במקור, נתוני הקופונים נשלפו מבסיס הנתונים באמצעות מספר רב של שאילתות נפרדות (לפי סטטוס, סוג וכו'). ריבוי שאילתות יצר עומס על בסיס הנתונים והאט את טעינת העמוד, במיוחד עבור משתמשים עם קופונים רבים.

**הפתרון:**
- **שאילתה מאוחדת:** כל הקופונים של המשתמש נשלפים כעת באמצעות **שאילתה אחת מרכזית**.
- **טעינה מדורגת (Lazy Loading):** כדי להאיץ את הטעינה הראשונית של העמוד, המערכת טוענת רק כמות מוגבלת של קופונים (למשל, 200 האחרונים). אם למשתמש יש יותר קופונים, הם נטענים באופן דינמי באמצעות קריאת AJAX נפרדת כאשר המשתמש גולל מטה.

**יתרונות:**
- הפחתה דרמטית של העומס על בסיס הנתונים (שאילתה אחת במקום 6-7).
- שיפור משמעותי בזמן הטעינה הראשוני של העמוד.

---

## 2. סינון נתונים בזיכרון (In-Memory Filtering)

**הבעיה:** לאחר שליפת הנתונים, היה צורך למיין אותם לקטגוריות שונות (קופונים פעילים, קופונים בשימוש, וכו').

**הפתרון:**
לאחר שהרשימה הראשונית של הקופונים נשלפת מה-DB, הסינון והחלוקה לקטגוריות מתבצעים **ישירות בזיכרון של שרת הפייתון**. פעולת סינון בזיכרון היא מהירה לאין שיעור מביצוע שאילתות DB נפרדות עבור כל קטגוריה.

**יתרונות:**
- מהירות תגובה גבוהה יותר של האפליקציה.
- הימנעות משאילתות מיותרות לבסיס הנתונים.

---

## 3. אופטימיזציה של עדכון סטטוס קופונים

**הבעיה:** עדכון הסטטוס של כל קופון (למשל, בדיקה אם פג תוקפו) היא פעולה יקרה שיכולה להתרחש בכל טעינת עמוד.

**הפתרון:**
כדי למנוע הרצה של הבדיקה הזו בכל פעם, המערכת משתמשת ב-**מטמון (cache) מבוסס Session**. הבדיקה מתבצעת רק **פעם אחת ביום** עבור כל משתמש. הסטטוס נשמר בסשן של המשתמש, ובטעינות הבאות של העמוד באותו היום, המערכת לא צריכה לבצע את הבדיקה מחדש.

**יתרונות:**
- הפחתת פעולות כבדות ומיותרות בכל טעינת עמוד.
- שיפור נוסף בזמני התגובה של העמוד.

---

## 4. חישוב סטטיסטיקות באמצעות אגרגציה ב-DB

**הבעיה:** חישובים סטטיסטיים, כמו סך החיסכון או כמות הקופונים מחברה מסוימת, בוצעו במקור על ידי לולאות שעברו על כל הקופונים בצד השרת (פייתון).

**הפתרון:**
החישובים הועברו לביצוע ישירות בבסיס הנתונים באמצעות **שאילתות אגרגציה** (`GROUP BY`, `SUM`, `COUNT`, וכו'). בסיסי נתונים ממוטבים לביצוע פעולות כאלה על כמויות גדולות של מידע.

**יתרונות:**
- מהירות חישוב גבוהה משמעותית.
- הפחתת השימוש בזיכרון בצד השרת.
- קוד פשוט וקריא יותר.
